% DO NOT CHANGE THESE!!!
\documentclass[10pt,a4paper,oneside]{article}
\usepackage{spankstyle}

% Change these as they should be!
\groupId{2}
\students{Konsta Hölttä, 79149S}{Nuutti Hölttä, 217437}{}
\topic{Virtual analog synthesis}
\platform{Freescale/Chameleon}

\newenvironment{V}{\begin{verbatim}}{\end{verbatim}}

% DO NOT CHANGE THESE!!!
\begin{document}
\maketitle

% Write your text here
\section{Introduction}

\cite{LaTeXhomepage}

Introduction - Short description of the project

In this project, a subtractive sound synthesizer based on the analog devices from 70's and 80's was implemented on a Chameleon DSP hardware. Our synth works on instruments, that contain separate oscillators, filters, ADSRs and LFOs. Oscillators generate sound samples, which are manipulated by the filters, finally producing audible output. The oscillator and filter behaviour can be tuned with ADSRs or LFOs in realtime. The notes are read from a MIDI connection or a test button on the panel.

The synth is written in a very modular way; new instruments are easily created. The system differs from analog synths mostly in the way that it is not monophonic, but instead we support instrument \emph channels that work like separate polyphonic instruments: when a new note is started, a new channel is reserved without killing the possibly playing old note on the same instrument. This mimics several identical analog instruments working in parallel. The notes end when their adsr finally releases, which usually happens after releasing the corresponding key on a keyboard.

The panel interface is not very convenient. Sorry about that. For maximal user experience, using a MIDI keyboard is recommended.


\section{Realization}

Detailed description of all functional parts of the algorithm, divide according to the functional parts

The program is divided into two high-level parts, the actual synth (written in DSP56k assembly) and a user interface with MIDI event and panel handling part (written in C). The synth runs on the DSP and the interface on the ColdFire.

The sampling frequency is 48000 Hz.

\subsection{Synth}

The synth code consists of oscillators and filters which are combined into instruments (with ADSR envelopes), and a main routine that evaluates the instruments and generates each sample.

The DSP uses 24-bit fixed-point math, i.e. usual calculations happen with values between $[-1,1)$, with uniform spacing (in contrast to floating-point). If, for example, a value needs to be multiplied by a value bigger than 1, the multiplier must be scaled down, and the final result must then be e.g. bit-shifted by the scaling factor. The number 1 also cannot be represented exactly as-is; the largest 24-bit fixed point value is $1-2^{-23}$. The accumulator registers are 56-bit, though, so they can hold larger intermediate values. From here on in this raport, in the context of fixed-point numbers, 1.0 shall be understood as $1-2^{-23}$, which is the value that is the closest to 1.0 in 24-bit fixed point representation.


\subsection{Main routine}

The main routine is what puts everything in the DSP part together. When the user presses a key on the MIDI keyboard, an interrupt is sent by the ColdFire to the DSP. The interrupt places its data into specific memory slots which are then read in the main loop. Whenever the code in the main loop detects that a key just went down, it proceeds to allocate a new "channel" for this new note - channels are data structures containing information about currently active notes (such as note number and instrument type). There is a fixed maximum number of channels, and if they're all in use when a new key-down event arrives, the new key is simply ignored. Otherwise, the channel's contents are initialized to appropriate values.

The output generation acts on a per-sample basis (in contrast to a block-based behavior). The samples are generated as follows. The main routine loops through the channels, and for each active channel, the corresponding instrument's oscillator and filter subroutines are called. The oscillator is evaluated first, and its output goes to the filter. The output of the filter is then modulated by an ADSR envelope. This is visualized in figure TODO.

The results of each channel are summed together to form the final output. The output is sent to the DAC peripheral, which syncs the sample rate.

When the user releases a key, an interrupt is sent in a manner similar to when a key went down. The main routine processes this event by finding the corresponding channel and marks it as released. The channel is not killed at this point; instead, the ADSR state is set to release. The channel is killed when the release stage ends, i.e. the ADSR value goes to zero.

\subsection{Oscillators}

Oscillators consist of a set of parameter and state values. Parameters are per-instrument, whereas the state contains data specific for an oscillator. When a new note is started, the oscillator's state is initialized with values depending on the note value. When an oscillator is evaluated, it generates its output value using these values. Furthermore, it advances its state so that the next time the oscillator is evaluated, it produces the next value. The output of an oscillator is a function of only the parameters and the state; that is, there is no global time counter.

\subsubsection{Sawtooth}

The sawtooth oscillator is basically just a counter that is incremented every time it is evaluated. The amount by which it is incremented depends on the frequency of the note and thus the MIDI note value. These constants are compile-time precalculated per each MIDI note (of which there are just 128, so not much memory is used). The value of the sawtooth ranges from -1.0 to 1.0; a neat branchless bit-shifting trick is used to wrap the values from $1.0+x$ back to $-1.0+x$.

\subsubsection{DPW sawtooth}

Because of the aliased nature of the pure sawtooth it sounds rather unpleasant, and it must be corrected using the DPW (differentiated parabolic waveform) method [TODO:ref]. DPW sawtooth basically outputs the derivative of a squared sawtooth. A DPW sawtooth oscillator is thus based on a pure sawtooth, but its state contains also the previous squared value of the sawtooth signal. Its evaluation consists of taking the difference of the square of the current value of the pure sawtooth and the previous squared value, scaled by a factor that depends on the frequency of the oscillator [ref:kaavaTODO] [fig:TODO].

\begin{verbatim}
  dpwSaw(n) = (saw(n)^2 - saw(n-1)^2) * c
\end{verbatim}

where

\[
  c = (f_s / (4*f * (1 - f/f_s)))
\]

$f$ is the saw's frequency and $f_s$ is the sampling frequency. \verb|saw(n)| is the pure saw function at the note frequency.

\subsubsection{DPW pulse}

Huovilainen presents the same problem as with sawtooths [TODO:ref], which is corrected here similarly. While a pure pulse wave is implementable as the difference of two phase-shifted pure sawtooths, a DPW pulse wave is similarly the difference of two DPW sawtooths. The amount of phase-shifting depends on the desired duty cycle of the pulse wave. The duty cycle can be modified on the fly, e.g. with a LFO.

\subsubsection{Noise}

The noise oscillator is implemented with a simple white noise pseudo-random xorshift algorithm [TODO:ref (googlella xorshift rngs, se pdf siitä)]. Unlike the other oscillators, the output of the noise oscillator doesn't vary according to the note, since white noise contains all frequencies. Instead it is convenient to combine this oscillator with e.g. a high-pass filter.

The xorshift algorithm corresponds to the following pseudo-code:

\begin{verbatim}
  v = previous output value (or seed)
  v = v ^ (v<<8)
  v = v ^ (v>>1)
  v = v ^ (v<<11)
  output = v
\end{verbatim}

where v is a 24-bit temporary, and logical shifts are used. The shift amounts were computed rather brute-forcily using methods presented in [TODO: ref toho samaiseen xorshiftpapruun]. The period of the pseudo-random number sequence is $2^{24} - 1$.

\subsubsection{Sine wave}


The sine wave is implemented with a lookup table with linear interpolation between the samples. Since a sine wave makes a rather uninteresting oscillator for an instrument, it is not used as such; instead it is used for LFOs. Since LFOs only require fairly low frequencies, this also permits the usage of a rather small lookup table without audible deficiencies.

\subsection{Filters}


Similarly to oscillators, filters also have parameters and states. Filter evaluation routines differ from oscillators in the way that oscillators take no per-sample input, whereas filters do take input, namely the output of an oscillator.

\subsubsection{Trivial lowpass}


This filter is a one-pole lowpass whose state contains its last output and the smoothing factor. The implementation is rather straightforward (a simple RC filter, see [ref:1-2005-verkkoon], however one must pay attention to fixed-point issues and scale values appropriately.

The output y changes according to the following pseudo-code (x is the input):

\begin{verbatim}
  y += (x-y) * g
\end{verbatim}

where

\[
  g = \frac{2 \pi t f_c}{2 \pi t f_c + 1}
  t = 1 / f_s
\]

$f_c$ is the cutoff frequency and $f_s$ is the sampling frequency.

\subsubsection{Trivial highpass}

This is structured quite similarly to the lowpass, only the output calculation differs.

The output y changes according to the following pseudo-code (x1 is the new input, x0 is the previous input):

\begin{verbatim}
  y = (y + x1 - x0) * g
\end{verbatim}

where

\[
  g = \frac{1}{2 \pi t f_c + 1}
  t = 1 / f_s
\]

$f_c$ is the cutoff frequency and $f_s$ is the sampling frequency.


\subsubsection{Four-pole versions}

Low- and high-pass filters are realized by implementing the digital moog filter as described in [välimhuov enkkupapru]. The feedback delay compensation is used, and the filter coefficients (such as the frequency) are compensated accordingly. Our implementation is missing the non-linearization effect, though. We implemented two filters, 4-pole lowpass and 4-pole highpass. The resonance is also there, but it seems a bit buggy. [kuva ja kuva]


\subsection{ADSR envelope}

The output volume of each channel is modulated with an attack-decay-sustain-release envelope generator. This makes the plain volume sound more instrument-like, when the volume jumps first up and then decays slowly to some level, imitating how real instruments are used. When a key is released, the volme decays slowly to zero. A normal ADSR is plotted in figure TODO. Our implementation consists of three separate stages: attack, decay, and release. Four parameters are used: time coefficients for attack, decay, and release, and a volume level for sustain. The envelope value changes exponentially in each stage towards a preset target value.

Attack and release stages have their time constant target beyond the actual value, i.e. if they would run infinitely, the envelope value would overshoot; this is because an exponentially decaying function never actually reaches its target exactly. After the specified attack time, our envelope will reach 1; after the release time, it will go to zero. The decay phase goes (virtually) infinitely long towards the sustain level. Finite-precision calculation makes this stop at some time, but it's not noticeable by human ear.

Table TODO. Filter parameters.

name		Specified as	Used and stored as
attack		Time			Modified LP coefficient
decay		Time			LP coefficient
sustain		Level			Final note volume
release		Time			Modified LP coefficient

An LP filter, i.e. exponentially decaying function, is used as in formula X:

 state += g * (target - state)

The coefficient g is computed from the time where approx. 63 \% (we'll call this $\lambda$) of the target value is reached (a time constant of an RC circuit represents the time it takes for the step response to reach $1-1/e$ of the target value):

\[
 g = 1 - e^(\frac{-1}{T * rate})
\]

Because of the natural decay constant $\lambda$, the attack and release target values are computed by multiplying the target value by

\[
 \lambda = \frac{e}{e-1} = ~0.63
\]

so that $\lambda$ of this new target is actually what we want (from zero to 1 in attack phase, or from the current value to 0 in release phase). The actual target $t$ is computed from the wanted value $w$ when starting value is $s$ with

\[
 \lambda * (t - s) = w - s
 t - s = (w - s) / \lambda
 t = s + (w - s) / \lambda
\]

In attack phase, this is (also visualized in figure TODO)

\[
 t = 0 + (1 - 0) / \lambda
   = 1 / \lambda = ~1.58
\]

and in release phase when the starting value $s$ represents the current state, the target becomes

\[
 t = s + (0 - s) / \lambda
   = (1 - \lambda) s
\]

Because the magnitudes of these coefficients will be over 1 and fixed-point calculation of the DSP deals with values between -1 and 1, we divide everything by 2 in the computation stage of the ADSR, and finally multiply by 2.


\subsection{Modulation}

In addition to the output ADSR, the instruments' oscillators and filters can be modulated with an ADSR, or an LFO. Because the instruments are implemented by hard-coding the signal handling in assembly, it's possible to multiply their outputs with a modulator or even change their state coefficients over time. As an example, we coded several instruments demonstrating this:

- filter cutoff modified with an ADSR
- filter cutoff modified with an LFO sinewave
- pulse oscillator duty cycle modified with an ADSR.


\subsection{Control interface}

The actual sound rendering code is in pure DSP assembly, but interfacing to the real world is done with the help of the ColdFire microcontroller. Code for it is written in C. In this chapter, the code and the user interface is described.

The microcontroller code runs several RTEMS tasks:

- panel interface handling
- midi reading
- DSP debugging reading
- Sequencer tracking


\subsubsection{Panel interface}

The user interface is as follows:

- Shift key	Panic button: kill all notes and clear the sequencer memory. Kind of a soft reset.
- Edit	Enable the sequencer recording and playback.
- Part up	Currently edited midi channel up.
- Part down	Currently edited midi channel down.
- Group up	Channel mapping up.
- Group down	Channel mapping down.
- Page up	Currently edited pot up.
- Page down	Currently edited pot down.
- Param up	Pot tunable up.
- Param down	Pot tunable down.
- Value up	Unused.
- Value down	Test note key.

The midi channel and potentiometer mappings are somewhat clumsy to use. First the currently edited item is selected with the "part" or "page" keys for channels or pots, and then the selected value can be rotated with "group" or "part" keys, respectively. Only the eight first midi channels can be mapped to synth instruments, so try to configure your keypad to one of these. Our keypad always sent its midi events to midi channel 0.

The value down key acts as one midi key at midi channel 0. The encoder turns the test note's note number up and down. There is no safety restrictions on changing the value beyond the [0,127] range.

The volume potentiometer works as expected.

\subsubsection{Midi code}

The midi task simply reads events from the MidiShare library and sends "note on" and "note off" events to the DSP via interrupts and the data port.

\subsubsection{DSP value reading}

This is a task from the template code to display words from the DSP on the panel. We output the clock cycles it took to render the last sample, to keep track of the code complexity.

\subsubsection{Sequencer}

The sequencer, when turned on, loops an array of fixed size 16, and sends all recorded key on or key off events at each slot to the DSP as if they were plain MIDI events. The event array consists of linked lists of event structures. The events are recoded when a MIDI event is handled. There is space for a maximum of 64 events total.


\section{Self-assessment}

Notes on the realization and division of the assignment workload between group members


\section{Conclusions}

Concluding remarks on the special assignment in whole


\section{Appendices}

The code well commented

\bibliographystyle{unsrt}
\bibliography{report}

\end{document}
